import { Vector3, Camera } from 'three';
import MapMesh from "./MapMesh";
import { TileData, TileDataSource, QR } from './interfaces';
import Grid from './Grid';
import MapViewController from './MapViewController';
import { MapViewControls } from './MapViewController';
import { MapMeshOptions } from './MapMesh';
import { Unit, Improvement } from './Units';
import { GameState, Player } from './GameState';
export default class MapView implements MapViewControls, TileDataSource {
    private static DEFAULT_ZOOM;
    private _camera;
    private _scene;
    private _renderer;
    private _labelRenderer;
    private _scrollDir;
    private _lastTimestamp;
    private _zoom;
    private _canvas;
    private _mapMesh;
    private _chunkedMesh;
    private _tileGrid;
    private _tileSelector;
    private _hoverSelector;
    private _arrow;
    private _controller;
    private _selectedTile;
    private _hoveredTile;
    private _units_models;
    private _units;
    private _gameState;
    private _onTileSelected;
    private _onLoaded;
    private _onAnimate;
    unitInfoPanel: HTMLElement;
    unitInfoCache: string;
    unitInfoIndex: string;
    placingCity: boolean;
    gameStatePanel: HTMLElement;
    menuPanel: HTMLElement;
    actionPanel: HTMLElement;
    resourcePanel: HTMLElement;
    readonly controller: MapViewController;
    readonly canvas: HTMLCanvasElement;
    readonly gameState: GameState;
    zoom: number;
    getZoom(): number;
    readonly selectedTile: TileData;
    getTileGrid(): Grid<TileData>;
    readonly mapMesh: MapMesh;
    /**
     * Sets up the camera with the given Z position (height) and so that the view center (the point the camera is pointed at) doesn't change.
     */
    setZoom(z: number): this;
    readonly scrollDir: Vector3;
    onTileSelected: (tile: TileData) => void;
    onLoaded: () => void;
    onAnimate: (dtS: number) => void;
    setOnAnimateCallback(callback: (dtS: number) => void): void;
    scrollSpeed: number;
    constructor(canvasElementQuery?: string);
    load(tiles: Grid<TileData>, options: MapMeshOptions): void;
    updateTiles(tiles: TileData[]): void;
    addUnitToMap(unit: Unit, tile: TileData): void;
    addImprovementToMap(improvement: Improvement, tile: TileData): void;
    initGameSetup(): void;
    toast({ text, icon, onClick }: {
        text: string;
        icon: string;
        onClick: () => void;
    }): void;
    getPlayer(name: string): Player;
    getTile(q: number, r: number): TileData;
    private animate;
    onWindowResize(event: Event): void;
    setScrollDir(x: number, y: number): void;
    getCamera(): Camera;
    /**
     * Returns the world space position on the Z plane (the plane with the tiles) at the center of the view.
     */
    getViewCenter(): Vector3;
    getCameraFocusPosition(pos: QR): Vector3;
    getCameraFocusPositionWorld(pos: Vector3): Vector3;
    focus(q: number, r: number): void;
    focusWorldPos(v: Vector3): void;
    hoverTile(tile: TileData): void;
    selectTile(tile: TileData): void;
    actionTile(tile: TileData): void;
    moveUnit(currentTile: TileData, targetTile: TileData): void;
    battle(currentTile: TileData, targetTile: TileData): void;
    battleCity(currentTile: TileData, targetTile: TileData): void;
    pickTile(worldPos: Vector3): TileData | null;
    getRandomTile(cityEligibile: boolean): TileData;
    isTileCityEligbile(tile: TileData): boolean;
    getClosestUnoccupiedTile(tile: TileData): TileData;
    getNextMovementTile(current: TileData, target: TileData): TileData;
    showEndTurnInActionPanel(): void;
    endTurn(): void;
    updateResourcePanel(): void;
    updateUnitInfoForTile(tile: TileData): void;
    updateGameStatePanel(): void;
    setActionPanel(action: string): void;
    actionPanelClicked(dataName: string): void;
    playerNegotiation(playerName: string): void;
    showLeaderMenu(info: string): void;
    showCityMenu(tile: TileData): void;
    checkForClearanceToAttack(player1: Player, player2: Player): boolean;
    cityMenuAction(name: string): void;
    playerDiplmaticAction(name: string, target: string): void;
    checkVictoryConditions(): void;
}
